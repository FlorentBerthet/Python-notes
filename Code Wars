# codewars.com

# Highest and Lowest (7kyu)

# Incorrect solution. 
# For some reason, gives '(ValueError: min() arg is an empty sequence)' even though it works on Sublime Text
  
def high_and_low(numbers):
    numbers = numbers.split(' ')
    numbers = map(int, numbers)
    numbers = max(numbers), min(numbers)
    numbers = str(numbers).replace("(", '"').replace(")",'"').replace(", "," ")
    print numbers

high_and_low("4 5 29 54 4 0 -214 542 -64 1 -3 6 -6")

# Correct solution:

def high_and_low(numbers):
    numbers = numbers.split(' ')
    numbers = sorted(numbers, key=int)
    return numbers[-1] + ' ' + numbers[0]


# Replace With Alphabet Position

from string import ascii_lowercase

IndexedLetters = {letter: str(index) for index, letter in enumerate(ascii_lowercase, start = 1)}

def alphabet_position(text):
    text=text.lower()
    Numbers = [IndexedLetters[character] for character in text if character in IndexedLetters]
    return ' '.join(Numbers)

# Solution 2

from string import ascii_uppercase

def alphabet_position(text):
    return " ".join(str(ascii_uppercase.index(i) + 1) for i in text.upper() if i in ascii_uppercase)

# Take a Ten Minute Walk

def is_valid_walk(walk):

    if len(walk) == 10 and walk.count('n') == walk.count('s') and walk.count('w') == walk.count('e'):
    	return True
    else:
        return False

# Solution 2

def isValidWalk(walk):
    return len(walk) == 10 and walk.count('n') == walk.count('s') and walk.count('e') == walk.count('w')

# Find the odd int

def find_it(seq):
    for i in seq:
    	if seq.count(i) %2 != 0:
    		return i

# Exes and Ohs

	# Check to see if a string has the same amount of 'x's and 'o's.
	# The method must return a boolean and be case insensitive. The string can contain any char.
def xo(s):
	if s.count('x')+s.count('X') == s.count('o')+s.count('O'):
        # if the sum of x's and X's is equal to the sum of o's and O's
		return True
	else:
		return False

# Solution 2

def xo(s):
    s = s.lower()
    return s.count('x') == s.count('o')

# Sum of odd numbers

"""
Given the triangle of consecutive odd numbers:
             1
          3     5
       7     9    11
   13    15    17    19
21    23    25    27    29
...
Calculate the row sums of this triangle from the row index (starting at index 1) e.g.:

row_sum_odd_numbers(1); # 1
row_sum_odd_numbers(2); # 3 + 5 = 8
"""

def row_sum_odd_numbers(n):
    # We can solve this with these 2 steps:
        # first_number_in_row = n**2 - (n-1)
        # sum_odd=first_number_in_row * n + (n-1) * n
            # first_number * n multiplies the first number in the row by the number of items in the row
            # (n-1) * n represents the sum of the differences between the subsequent numbers and the first number
    # Merging these two gives us the solution below.

sum_odd=(n**2 - (n-1))*n + (n-1)*n

   return sum_odd

# Solution 2

def row_sum_odd_numbers(n):
    return n ** 3

# Create Phone Number

    # Write a function that accepts an array of 10 integers (between 0 and 9), that returns a string of those numbers in the form of a phone number.
    # Example:
        # create_phone_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) # => returns "(123) 456-7890"

def create_phone_number(n):
    phone_number='('
    for i, num in enumerate(n):
        if i<2:
            phone_number += str(num)
        elif i==2:
            phone_number += str(num)+') '
        elif i<5:
            phone_number += str(num)
        elif i==5:
            phone_number += str(num)+'-'
        elif i<9:
            phone_number += str(num)
        elif i==9:
            phone_number += str(num)
    return(phone_number)

# Solution 2

def create_phone_number(n):
    return "({}{}{}) {}{}{}-{}{}{}{}".format(*n)

# Is a number prime?

def is_prime(n):

    if (n <= 1):
        return False
    if (n <= 3):
        return True

    if (n % 2 == 0 or n % 3 == 0):
        return False

    i = 5
    while(i * i <= n):
        if (n % i == 0 or n % (i + 2) == 0):
            return False
        i = i + 6

    return True

# Solution 2

def is_prime(num):
    import math

    # There's only one even prime: 2
    if num < 2    : return False
    if num == 2   : return True
    if num %2 == 0: return False

    
    """
    Property:
        Every number n that is not prime has at least one prime divisor p
        such 1 < p < square_root(n)
    """
    root = int(math.sqrt(num))
    
    # We know there's only one even prime, so with that in mind 
    # we're going to iterate only over the odd numbers plus using the above property
    # the performance will be improved
    for i in xrange(3, root+1, 2):
        if num % i == 0: return False

    return True

# Solution 3

from math import sqrt

def is_prime(n):
  return n > 1 and all(n % d for d in xrange(2, int(sqrt(n)) + 1))

# Convert string to camel case

'''
Complete the method/function so that it converts dash/underscore delimited words into camel casing.
The first word within the output should be capitalized only if the original word was capitalized (known as Upper Camel Case,
also often referred to as Pascal case).

Examples

to_camel_case("the-stealth-warrior") # returns "theStealthWarrior"

to_camel_case("The_Stealth_Warrior") # returns "TheStealthWarrior"

'''

from string import ascii_letters

def to_camel_case(text):
    
    # Creating a dictionary with each possible part to replace and their replacement
    xdic={}

    for i in ascii_letters:
        xdic['_'+i]=i.upper()
        xdic['-'+i]=i.upper()

    for key in xdic:
        text=text.replace(key, xdic[key])

    return(text)

# Solution 2

def to_camel_case(s):
    return s[0] + s.title().translate(None, "-_")[1:] if s else s
   
# Solution 3

def to_camel_case(text):
    return text[:1] + text.title()[1:].replace('_', '').replace('-', '')
